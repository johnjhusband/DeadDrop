<!-- Uploads.html -->
<!DOCTYPE html>
<!--
  DeadDrop v3.5.14 - Frontend
  Server-Side OAuth + Drive API for File/Folder Upload
  Supports: Desktop (file + folder), Mobile (file only)

  v3.5.14 Update (2026-01-26):
  - Added detailed logging for server-side chunk upload failures
  - Shows elapsed time and suggests timeout/memory issues

  v3.5.13 Update (2026-01-26):
  - Proxy chunk uploads through server to avoid CORS (browser -> Apps Script -> Drive API)
  - Reduced chunk size from 256MB to 32MB (google.script.run has ~50MB limit)

  v3.5.12 Update (2026-01-26):
  - Added detailed chunk upload logging (file size, chunk count, each request, full error details)

  v3.5.11 Update (2026-01-26):
  - Removed Authorization header from chunk uploads (session URL contains auth, header causes CORS preflight failure)

  v3.5.10 Update (2026-01-26):
  - Improved error logging to show in UI instead of console

  v3.5.9 Update (2026-01-26):
  - Changed button text from "Choose" to "Upload"
  - Added detailed error logging for chunk upload failures

  v3.5.8 Update (2026-01-26):
  - Backend fix: added userinfo.email scope for folder sharing

  v3.5.7 Update (2026-01-26):
  - Backend fix: folder shared with user so their OAuth token works for uploads

  v3.5.6 Update (2026-01-25):
  - Upload now starts automatically when files/folder selected (removed Start Upload button)
  - Fixed 404 upload error (backend fix: uses owner's token for upload sessions)

  v3.5.5 Update (2025-01-25):
  - Fixed duplicate folder nesting bug in folder uploads
  - extractFolderPaths() now strips root folder name (already in upload folder name)
  - uploadFile() now strips root folder name from folderPath

  v3.5.3 Update (2025-01-16):
  - Fixed CORS error on chunk uploads
  - Chunk uploads now include Authorization header with same token used for session creation
  - Server returns accessToken from createUploadSession() for client to use
  - INSTALL.md: Removed GCP project linking step (was breaking drive.file scope)

  v3.5.2 Update (2025-01-16):
  - Fixed 404 error on file upload (Drive API not accessible from client)
  - Upload session now created server-side via createUploadSession()

  v3.5.1 Update (2025-01-16):
  - Fixed folder creation permission error (drive.file scope issue)
  - createFolderHierarchyClientSide now calls server-side createFolder()
  - Folders created using owner's DriveApp permissions instead of user's OAuth token

  v3.5 Update (2025-01-13):
  - Added mobile device support (iPhone, Android)
  - Added single/multiple file selection alongside folder selection
  - Transparent UI adapts to device capability
  - Desktop: Can select files OR folders
  - Mobile: Can select single or multiple files

  v3.4 Update (2025-12-01):
  - Moved folder hierarchy creation from server-side to client-side
  - Folders created directly from browser (no Apps Script time limits)
  - Fixes timeout errors with large folder structures (7000+ folders)
-->
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Upload Files - Wildfire Video</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/spark-md5/3.0.2/spark-md5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      padding: 40px 30px;
      text-align: center;
    }

    .logo {
      font-size: 32px;
      font-weight: 800;
      color: #ffffff;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .tagline {
      color: rgba(255, 255, 255, 0.95);
      font-size: 14px;
      margin-top: 8px;
    }

    .content {
      padding: 40px 30px;
    }

    .auth-section {
      text-align: center;
    }

    .sign-in-btn {
      background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 16px;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .sign-in-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(255, 107, 53, 0.3);
    }

    .upload-section {
      display: none;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }

    input[type="text"] {
      width: 100%;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #ff6b35;
    }

    .file-input-wrapper {
      position: relative;
      display: inline-block;
      width: 100%;
    }

    input[type="file"] {
      display: none;
    }

    .file-input-btn {
      display: block;
      width: 100%;
      padding: 40px 20px;
      background: #f8f9fa;
      border: 3px dashed #d0d0d0;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }

    .file-input-btn:hover {
      background: #e9ecef;
      border-color: #ff6b35;
    }

    .file-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }

    .selection-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .selection-btn {
      padding: 12px 24px;
      border: 2px solid #ff6b35;
      background: white;
      color: #ff6b35;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .selection-btn:hover {
      background: #ff6b35;
      color: white;
    }

    .selection-btn.primary {
      background: #ff6b35;
      color: white;
    }

    .selection-btn.primary:hover {
      background: #e55a2b;
    }

    .mobile-note {
      font-size: 12px;
      color: #666;
      margin-top: 10px;
      text-align: center;
    }

    .file-list {
      margin-top: 20px;
      max-height: 400px;
      overflow-y: auto;
    }

    .file-item {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 10px;
    }

    .file-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
      gap: 5px;
    }

    .file-name {
      font-weight: 600;
      color: #333;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      min-width: 100px;
    }

    .file-size {
      color: #666;
      font-size: 12px;
      margin-left: 10px;
    }

    .file-status {
      font-size: 12px;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
      margin-left: 10px;
    }

    .status-pending { background: #e3f2fd; color: #1976d2; }
    .status-uploading { background: #fff3e0; color: #f57c00; }
    .status-verifying { background: #e1f5fe; color: #0288d1; }
    .status-complete { background: #e8f5e9; color: #388e3c; }
    .status-failed { background: #ffebee; color: #d32f2f; }

    .progress-bar-container {
      width: 100%;
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ff6b35 0%, #f7931e 100%);
      transition: width 0.3s;
      width: 0%;
    }

    .file-error {
      color: #d32f2f;
      font-size: 12px;
      margin-top: 5px;
    }

    .batch-summary {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .upload-btn, .cancel-btn {
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      margin-right: 10px;
    }

    .upload-btn {
      background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      color: white;
    }

    .upload-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(255, 107, 53, 0.3); }
    .upload-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

    .cancel-btn {
      background: #f44336;
      color: white;
    }

    .clear-btn {
      padding: 8px 16px;
      border: 1px solid #ccc;
      background: white;
      color: #666;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }

    .clear-btn:hover {
      background: #f5f5f5;
    }

    .debug-log {
      margin-top: 20px;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }

    .log-entry {
      margin-bottom: 5px;
      color: #333;
    }

    .log-error { color: #d32f2f; font-weight: 600; }
    .log-success { color: #388e3c; font-weight: 600; }

    .help-text {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }

    .completion-summary {
      text-align: center;
      padding: 30px;
      display: none;
    }

    .completion-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }

    .completion-title {
      font-size: 24px;
      font-weight: 700;
      color: #333;
      margin-bottom: 10px;
    }

    .completion-stats {
      font-size: 14px;
      color: #666;
      margin-bottom: 20px;
    }

    /* Mobile responsive */
    @media (max-width: 600px) {
      .header {
        padding: 30px 20px;
      }
      .logo {
        font-size: 24px;
      }
      .content {
        padding: 30px 20px;
      }
      .file-item-header {
        flex-direction: column;
        align-items: flex-start;
      }
      .file-size, .file-status {
        margin-left: 0;
        margin-top: 5px;
      }
      .selection-buttons {
        flex-direction: column;
      }
      .selection-btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">Wildfire Video</div>
      <div class="tagline">Professional Video Upload Portal</div>
    </div>

    <div class="content">
      <!-- Authentication Section -->
      <div id="authSection" class="auth-section">
        <p style="margin-bottom: 20px; color: #666;">Sign in with your Google account to upload files</p>
        <button id="signInBtn" class="sign-in-btn">Sign in with Google</button>
      </div>

      <!-- Upload Section -->
      <div id="uploadSection" class="upload-section">
        <!-- Project Name Input -->
        <div class="form-group">
          <label for="projectName">Project Name (Optional)</label>
          <input type="text" id="projectName" placeholder="e.g., LawFirm_Commercial or leave blank to use file/folder name">
          <div class="help-text">If left blank, the selected folder or first file name will be used</div>
        </div>

        <!-- File/Folder Selection -->
        <div class="form-group">
          <label>Select Files or Folder</label>
          <div class="file-input-wrapper">
            <!-- Hidden file inputs -->
            <input type="file" id="fileInput" multiple>
            <input type="file" id="folderInput" webkitdirectory multiple>

            <div class="file-input-btn" id="fileInputArea">
              <div class="file-icon" id="fileIcon">üìÅ</div>
              <div id="selectText"><strong>Select files to upload</strong></div>
              <div class="help-text" id="capabilityText">Loading...</div>

              <div class="selection-buttons" id="selectionButtons">
                <!-- Buttons will be added dynamically based on device capability -->
              </div>
            </div>
          </div>
        </div>

        <!-- Batch Summary -->
        <div id="batchSummary" class="batch-summary" style="display: none;">
          <div class="summary-row">
            <span><strong>Files Selected:</strong></span>
            <span id="fileCount">0</span>
          </div>
          <div class="summary-row">
            <span><strong>Total Size:</strong></span>
            <span id="totalSize">0 MB</span>
          </div>
          <div class="summary-row">
            <span><strong>Upload Type:</strong></span>
            <span id="uploadType">-</span>
          </div>
          <div class="summary-row">
            <span><strong>Status:</strong></span>
            <span id="batchStatus">Ready</span>
          </div>
        </div>

        <!-- File List -->
        <div id="fileList" class="file-list"></div>

        <!-- Upload Controls -->
        <div id="uploadControls" style="margin-top: 20px; display: none;">
          <button id="cancelBtn" class="cancel-btn" style="display: none;">Cancel Upload</button>
          <button id="clearBtn" class="clear-btn" style="display: none;">Clear Selection</button>
        </div>

        <!-- Completion Summary -->
        <div id="completionSummary" class="completion-summary">
          <div class="completion-icon">‚úÖ</div>
          <div class="completion-title">Upload Complete!</div>
          <div class="completion-stats" id="completionStats"></div>
          <button onclick="location.reload()" class="upload-btn">Upload More Files</button>
        </div>

        <!-- Debug Log -->
        <div id="debugLog" class="debug-log"></div>
      </div>
    </div>
  </div>

  <script>
    // ========== GLOBAL VARIABLES ==========

    const CHUNK_SIZE = 32 * 1024 * 1024; // 32MB chunks (must fit in google.script.run ~50MB limit after base64)
    const MAX_FILE_SIZE = 750 * 1024 * 1024 * 1024; // 750GB

    let selectedFiles = [];
    let uploadCancelled = false;
    let accessToken = null;
    let isFolder = false; // Track if selection was a folder
    let isMobile = false;
    let supportsFolderUpload = false;

    // ========== DEVICE DETECTION ==========

    function detectCapabilities() {
      // Detect mobile
      isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      // Detect folder upload support (webkitdirectory)
      const testInput = document.createElement('input');
      testInput.type = 'file';
      supportsFolderUpload = 'webkitdirectory' in testInput && !isMobile;

      log('Device: ' + (isMobile ? 'Mobile' : 'Desktop'));
      log('Folder upload support: ' + (supportsFolderUpload ? 'Yes' : 'No'));

      setupUI();
    }

    function setupUI() {
      const selectionButtons = document.getElementById('selectionButtons');
      const capabilityText = document.getElementById('capabilityText');
      const fileIcon = document.getElementById('fileIcon');
      const selectText = document.getElementById('selectText');

      selectionButtons.innerHTML = '';

      if (isMobile) {
        // Mobile: Only file selection
        fileIcon.textContent = 'üìÑ';
        selectText.innerHTML = '<strong>Select files to upload</strong>';
        capabilityText.textContent = 'Select one or more files (750GB max per file)';

        const fileBtn = document.createElement('button');
        fileBtn.className = 'selection-btn primary';
        fileBtn.textContent = 'Upload Files';
        fileBtn.onclick = (e) => { e.stopPropagation(); document.getElementById('fileInput').click(); };
        selectionButtons.appendChild(fileBtn);

      } else {
        // Desktop: Both file and folder selection
        fileIcon.textContent = 'üìÅ';
        selectText.innerHTML = '<strong>Select files or folder to upload</strong>';
        capabilityText.textContent = 'Select files or an entire folder (750GB max per file)';

        const fileBtn = document.createElement('button');
        fileBtn.className = 'selection-btn';
        fileBtn.textContent = 'Upload Files';
        fileBtn.onclick = (e) => { e.stopPropagation(); document.getElementById('fileInput').click(); };
        selectionButtons.appendChild(fileBtn);

        if (supportsFolderUpload) {
          const folderBtn = document.createElement('button');
          folderBtn.className = 'selection-btn primary';
          folderBtn.textContent = 'Upload Folder';
          folderBtn.onclick = (e) => { e.stopPropagation(); document.getElementById('folderInput').click(); };
          selectionButtons.appendChild(folderBtn);
        }
      }
    }

    // ========== PAGE LOAD ==========

    window.addEventListener('DOMContentLoaded', () => {
      log('Page loaded');

      // Detect device capabilities
      detectCapabilities();

      // Check if user is already authorized
      checkAuthorization();

      // Setup event listeners
      document.getElementById('signInBtn').addEventListener('click', handleSignIn);
      document.getElementById('fileInput').addEventListener('change', handleFileSelect);
      document.getElementById('folderInput').addEventListener('change', handleFolderSelect);
      document.getElementById('clearBtn').addEventListener('click', clearSelection);
      document.getElementById('cancelBtn').addEventListener('click', () => {
        uploadCancelled = true;
        log('Upload cancelled by user');
      });

    });

    // ========== OAUTH AUTHENTICATION ==========

    function checkAuthorization() {
      log('Checking authorization status...');

      google.script.run
        .withSuccessHandler(authorized => {
          if (authorized) {
            log('User is authorized');
            showUploadSection();
          } else {
            log('User not authorized - showing sign in');
            showAuthSection();
          }
        })
        .withFailureHandler(err => {
          log('ERROR checking authorization: ' + err.message, true);
          showAuthSection();
        })
        .isAuthorized();
    }

    function handleSignIn() {
      log('Getting authorization URL...');

      google.script.run
        .withSuccessHandler(authUrl => {
          log('Opening authorization popup...');

          // Open auth URL in popup
          const width = 600;
          const height = 700;
          const left = (screen.width - width) / 2;
          const top = (screen.height - height) / 2;

          const popup = window.open(
            authUrl,
            'oauth',
            'width=' + width + ',height=' + height + ',left=' + left + ',top=' + top
          );

          // Poll for popup close
          const pollTimer = setInterval(() => {
            if (popup.closed) {
              clearInterval(pollTimer);
              log('Popup closed - checking authorization...');

              // Wait a moment for OAuth callback to complete
              setTimeout(() => {
                checkAuthorization();
              }, 1000);
            }
          }, 500);
        })
        .withFailureHandler(err => {
          log('ERROR getting auth URL: ' + err.message, true);
          showError('Failed to initialize authorization: ' + err.message);
        })
        .getAuthUrl();
    }

    function showAuthSection() {
      document.getElementById('authSection').style.display = 'block';
      document.getElementById('uploadSection').style.display = 'none';
    }

    function showUploadSection() {
      document.getElementById('authSection').style.display = 'none';
      document.getElementById('uploadSection').style.display = 'block';
    }

    // ========== FILE SELECTION ==========

    function handleFileSelect(e) {
      const files = Array.from(e.target.files);
      if (files.length > 0) {
        processFiles(files, false);
      }
    }

    function handleFolderSelect(e) {
      const files = Array.from(e.target.files);
      if (files.length > 0) {
        processFiles(files, true);
      }
    }

    function processFiles(files, isFolderSelection) {
      if (files.length === 0) {
        log('No files selected');
        return;
      }

      isFolder = isFolderSelection;
      log('Processing ' + files.length + ' file(s), folder mode: ' + isFolder);

      // Validate files
      selectedFiles = files.filter(file => {
        if (file.size > MAX_FILE_SIZE) {
          log('Skipping file (too large): ' + file.name + ' (' + formatFileSize(file.size) + ')', true);
          return false;
        }
        return true;
      });

      if (selectedFiles.length === 0) {
        showError('No valid files selected');
        return;
      }

      displayFiles();
      document.getElementById('uploadControls').style.display = 'block';

      // Auto-start upload
      startUpload();
    }

    function clearSelection() {
      selectedFiles = [];
      isFolder = false;
      document.getElementById('fileInput').value = '';
      document.getElementById('folderInput').value = '';
      document.getElementById('fileList').innerHTML = '';
      document.getElementById('batchSummary').style.display = 'none';
      document.getElementById('uploadControls').style.display = 'none';
      log('Selection cleared');
    }

    function displayFiles() {
      const fileList = document.getElementById('fileList');
      const batchSummary = document.getElementById('batchSummary');

      fileList.innerHTML = '';

      let totalSize = 0;

      selectedFiles.forEach((file, index) => {
        totalSize += file.size;

        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.id = 'file-' + index;

        const displayPath = file.webkitRelativePath || file.name;

        fileItem.innerHTML = `
          <div class="file-item-header">
            <div class="file-name" title="${displayPath}">${displayPath}</div>
            <div class="file-size">${formatFileSize(file.size)}</div>
            <div class="file-status status-pending" id="status-${index}">Pending</div>
          </div>
          <div class="progress-bar-container">
            <div class="progress-bar" id="progress-${index}"></div>
          </div>
          <div class="file-error" id="error-${index}" style="display: none;"></div>
        `;

        fileList.appendChild(fileItem);
      });

      document.getElementById('fileCount').textContent = selectedFiles.length;
      document.getElementById('totalSize').textContent = formatFileSize(totalSize);
      document.getElementById('uploadType').textContent = isFolder ? 'Folder (preserves structure)' : 'Files';
      batchSummary.style.display = 'block';
    }

    // ========== UPLOAD ==========

    async function startUpload() {
      log('Starting upload...');

      document.getElementById('cancelBtn').style.display = 'inline-block';
      document.getElementById('clearBtn').style.display = 'none';
      uploadCancelled = false;

      try {
        // Get access token
        log('Getting access token...');
        accessToken = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getAccessToken();
        });

        log('Access token obtained');

        // Get project name
        let projectName = document.getElementById('projectName').value.trim();
        if (!projectName) {
          if (isFolder && selectedFiles[0].webkitRelativePath) {
            // Use folder name
            projectName = selectedFiles[0].webkitRelativePath.split('/')[0];
          } else {
            // Use first filename without extension
            projectName = selectedFiles[0].name.replace(/\.[^/.]+$/, '');
          }
        }

        // Calculate total size
        const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);

        // Prepare upload (create folder)
        log('Preparing upload folder...');
        const prepareResult = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .prepareUpload(projectName, selectedFiles.length, totalSize);
        });

        if (!prepareResult.success) {
          throw new Error(prepareResult.message);
        }

        log('Upload folder created: ' + prepareResult.folderName);
        const rootFolderId = prepareResult.folderId;

        // Handle folder structure if this was a folder selection
        let folderIdMap = { '': rootFolderId };

        if (isFolder) {
          // Extract folder structure
          const folderPaths = extractFolderPaths(selectedFiles);
          log('Folder paths to create: ' + folderPaths.length);

          if (folderPaths.length > 0) {
            log('Creating folder hierarchy...');
            folderIdMap = await createFolderHierarchyClientSide(rootFolderId, folderPaths);
            log('Folder hierarchy created');
          }
        }

        // Upload files
        for (let i = 0; i < selectedFiles.length; i++) {
          if (uploadCancelled) {
            log('Upload cancelled');
            break;
          }

          const file = selectedFiles[i];
          await uploadFile(file, i, folderIdMap);
        }

        if (!uploadCancelled) {
          showCompletion();
        }

      } catch (error) {
        log('ERROR in upload: ' + error.message, true);
        showError('Upload failed: ' + error.message);
      } finally {
        document.getElementById('cancelBtn').style.display = 'none';
        document.getElementById('clearBtn').style.display = 'inline-block';
      }
    }

    async function uploadFile(file, index, folderIdMap) {
      const displayName = file.webkitRelativePath || file.name;
      log('Uploading: ' + displayName);

      updateFileStatus(index, 'uploading', 'Uploading...');

      try {
        // Get folder path from webkitRelativePath (if folder upload)
        let folderPath = '';
        if (isFolder && file.webkitRelativePath) {
          const parts = file.webkitRelativePath.split('/');
          parts.pop(); // Remove filename
          parts.shift(); // Remove root folder name (already in upload folder name)
          folderPath = parts.join('/');
        }

        const targetFolderId = folderIdMap[folderPath] || folderIdMap[''];

        // Create resumable upload session via server (uses owner's credentials)
        const sessionResult = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .createUploadSession(file.name, file.type || 'application/octet-stream', targetFolderId);
        });

        console.log('Session result:', sessionResult);

        if (!sessionResult.success) {
          throw new Error('Failed to initialize upload: ' + sessionResult.message);
        }

        const sessionUrl = sessionResult.sessionUrl;

        log('Session URL: ' + sessionUrl.substring(0, 80) + '...');
        log('File size: ' + file.size + ' bytes');
        log('File type: ' + (file.type || 'unknown'));

        // Upload file in chunks via server (avoids CORS)
        const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
        log('Total chunks: ' + totalChunks + ' (chunk size: ' + CHUNK_SIZE + ')');
        let uploadedBytes = 0;

        for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
          if (uploadCancelled) return;

          const start = chunkIndex * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, file.size);
          const chunk = file.slice(start, end);

          log('Chunk ' + (chunkIndex + 1) + '/' + totalChunks + ': bytes ' + start + '-' + (end - 1) + ' (' + chunk.size + ' bytes)');

          // Convert chunk to base64
          const chunkBase64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
            reader.readAsDataURL(chunk);
          });

          // Upload chunk via server (avoids CORS)
          log('Sending chunk to server...');
          const startTime = Date.now();
          let chunkResult;
          try {
            chunkResult = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler((error) => {
                  reject(new Error('Server call failed: ' + (error.message || error)));
                })
                .uploadChunk(sessionUrl, chunkBase64, start, end, file.size);
            });
          } catch (serverError) {
            const elapsed = Math.round((Date.now() - startTime) / 1000);
            log('Server call failed after ' + elapsed + 's: ' + serverError.message, true);
            log('This may be a timeout (60s limit) or memory issue on server', true);
            throw serverError;
          }
          const elapsed = Math.round((Date.now() - startTime) / 1000);
          log('Server responded in ' + elapsed + 's: ' + JSON.stringify(chunkResult));

          if (!chunkResult.success) {
            throw new Error('Chunk upload failed: ' + (chunkResult.message || 'HTTP ' + chunkResult.status));
          }

          uploadedBytes = end;
          const progress = Math.round((uploadedBytes / file.size) * 100);
          updateFileProgress(index, progress);
        }

        updateFileStatus(index, 'complete', 'Complete');
        log('Uploaded: ' + displayName, false, true);

      } catch (error) {
        log('ERROR uploading ' + displayName + ': ' + error.message, true);
        updateFileStatus(index, 'failed', 'Failed');
        updateFileError(index, error.message);
      }
    }

    function extractFolderPaths(files) {
      const paths = new Set();

      files.forEach(file => {
        if (file.webkitRelativePath) {
          const parts = file.webkitRelativePath.split('/');
          parts.pop(); // Remove filename
          parts.shift(); // Remove root folder name (already in upload folder name)

          let currentPath = '';
          parts.forEach(part => {
            currentPath += (currentPath ? '/' : '') + part;
            paths.add(currentPath);
          });
        }
      });

      return Array.from(paths);
    }

    async function createFolderHierarchyClientSide(rootFolderId, folderPaths) {
      const folderIdMap = { '': rootFolderId };

      // Sort by depth (shallowest first)
      const sortedPaths = folderPaths.sort((a, b) =>
        a.split('/').length - b.split('/').length
      );

      for (const path of sortedPaths) {
        if (uploadCancelled) break;

        const parts = path.split('/');
        const parentPath = parts.slice(0, -1).join('/');
        const folderName = parts[parts.length - 1];
        const parentFolderId = folderIdMap[parentPath];

        // Create folder using server-side function (owner's permissions)
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .createFolder(folderName, parentFolderId);
        });

        if (!result.success) {
          throw new Error('Failed to create folder: ' + folderName + ' - ' + result.message);
        }

        folderIdMap[path] = result.folderId;
      }

      return folderIdMap;
    }

    // ========== UI UPDATES ==========

    function updateFileStatus(index, status, text) {
      const statusEl = document.getElementById('status-' + index);
      if (statusEl) {
        statusEl.className = 'file-status status-' + status;
        statusEl.textContent = text;
      }
    }

    function updateFileProgress(index, percent) {
      const progressEl = document.getElementById('progress-' + index);
      if (progressEl) {
        progressEl.style.width = percent + '%';
      }
    }

    function updateFileError(index, message) {
      const errorEl = document.getElementById('error-' + index);
      if (errorEl) {
        errorEl.textContent = message;
        errorEl.style.display = 'block';
      }
    }

    function showCompletion() {
      document.getElementById('completionSummary').style.display = 'block';
      document.getElementById('fileList').style.display = 'none';
      document.getElementById('uploadControls').style.display = 'none';
      document.getElementById('batchSummary').style.display = 'none';

      const completed = selectedFiles.length;
      const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);

      document.getElementById('completionStats').textContent =
        completed + ' file(s) (' + formatFileSize(totalSize) + ') uploaded successfully';
    }

    function showError(message) {
      alert('Error: ' + message);
    }

    // ========== UTILITIES ==========

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }

    function log(message, isError = false, isSuccess = false) {
      const timestamp = new Date().toLocaleTimeString();
      const entry = '[' + timestamp + '] ' + message;

      console.log(entry);

      const debugLog = document.getElementById('debugLog');
      const logEntry = document.createElement('div');
      logEntry.className = 'log-entry' + (isError ? ' log-error' : '') + (isSuccess ? ' log-success' : '');
      logEntry.textContent = entry;
      debugLog.appendChild(logEntry);
      debugLog.scrollTop = debugLog.scrollHeight;
    }
  </script>
</body>
</html>
